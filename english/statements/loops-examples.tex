\levelThreeTitle{Examples with read-only arrays}


Array is the most common data structure when we are working with loops.
It is then a good example base to exercise with loops, and these
examples allow to rapidly show interesting invariant and will allow us
to introduce some important ACSL constructs.



We can for example use the search function that allows to find a value
inside an array:


\CodeBlockInput{c}{search.c}



There are enough ideas inside this example to introduce some important
syntax.



First, as we previously presented, the
\CodeInline{\textbackslash{}valid\_read} predicate (as well as
\CodeInline{\textbackslash{}valid}) allows us to specify not only the
validity of read-only address but also to state that a range of
contiguous addresses is valid. It is expressed using this expression:



\begin{CodeBlock}{c}
//@ requires \valid_read(a + (0 .. length-1));
\end{CodeBlock}



Cette pré-condition nous atteste que les adresses a+0, a+1 ..., a+length-1 sont
valides en lecture.



This precondition states that all addresses a+0, a+1, \ldots{},
a+length-1 are valid read-only locations.

We also introduced two notations that are used almost all the time in
ACSL, the keywords \CodeInline{\textbackslash{}forall} ($\forall$) and
\CodeInline{\textbackslash{}exists} ($\exists$), the universal logic
quantifiers. The first allows to state that for any element, some
property is true, the second allows to say that there exists some
element such that the property is true. If we comment a little bit the
corresponding lines in our specification, we can read them this way:


\begin{CodeBlock}{c}
/*@
// for all "off" of type "size_t", such that IF "off" is comprised between 0 and "length"
//                                 THEN the cell "off" in "a" is different of "element"
\forall size_t off ; 0 <= off < length ==> a[off] != element;

// there exists "off" of type "size_t", such that "off" is comprise between 0 and "length"
//                                      AND the cell "off" in "a" equals to "element"
\exists size_t off ; 0 <= off < length && a[off] == element;
*/
\end{CodeBlock}



If we want to sum up the use of these keyword, we would say that on a
range of values, a property is true, either about at least one of them
or about all of them. A common scheme is to constraint this set using
another property (here: \CodeInline{0 <= off < length}) puis nous voudrons prouver la
propriété réelle qui nous intéresse à propos d'eux.  and to prove the
actual interesting property on this smaller set. \textbf{But using
\texttt{exists} and \texttt{forall} is fundamentally different}.



With \CodeInline{\textbackslash{}forall type a ; p(a) ==> q(a)},
the constraint \CodeInline{p} is followed by an implication. For all
element, if a first property \CodeInline{p} is verified about it, then we
have to verify the second property \CodeInline{q}. If we use a conjunction,
as we do for ``exists'' (that we will later explain), that would mean
that all element verify both \CodeInline{p} and \CodeInline{q}. Sometimes, it
could be what we want to express, but it would then not correspond
anymore to the idea of constraining a set for which we want to verify
some other property



With \CodeInline{\textbackslash{}exists type a ; p(a) \&\& q(a)}, the
constraint \texttt{p} is followed by a conjunction. We say there exists
an element such that it satisfies the property \texttt{p} at the same
time it also satisfies \texttt{q}. If we use an implication, as we do
for ``forall'', such an expression will always be true if \texttt{p} is
not a tautology! Why? Is there a ``a'' such that p(a) implies q(a) ? Let
us take a ``a'' such that p(a) is false, the implication is true.



This part of the invariant deserves a particular attention:



\begin{CodeBlock}{c}
//@ loop invariant \forall size_t j; 0 <= j < i ==> array[j] != element;
\end{CodeBlock}



Indeed, it defines the treatment performed by our loop, it indicates to
WP what happens inside the loop (or more precisely: what we learn) along
the execution. Here, this formula indicates that at each iteration of
the loop, we know that for each memory location between 0 and the next
location to visit (\CodeInline{i} excluded), the memory location contains a
value different of the element we are looking for.

The proof obligation associated to the preservation of this invariant is
a bit complex and it is not really interesting to precisely look at it,
on the contrary, the proof that the invariant is established before
executing the loop is interesting:



\image{trivial}[Trivial goal]


We note that this property, while quite complex, is proved easily proved
by Qed. If we look at the parts of the programs on which the proof
relies, we can see that the instruction \CodeInline{i = 0} is highlighted
and this is, indeed, the last instruction executed on \CodeInline{i} before
we start the loop. And consequently if we replace the value of
\CodeInline{i} by 0 inside the formula of the invariant, we get:



\begin{CodeBlock}{c}
//@ loop invariant \forall size_t j; 0 <= j < 0 ==> array[j] != element;
\end{CodeBlock}



``For all j, greater or equal to 0 and strictly lower than 0'', this
part of the formula is necessarily false, our implication is then
necessarily true.



\levelThreeTitle{Examples with mutable arrays}


Let us present two examples with mutation of arrays. One with a mutation
of all memory locations, the other with selective modifications.



\levelFourTitle{Reset}


Let us have a look to the function that resets an array of integer to 0.



\CodeBlockInput{c}{reset.c}



Let us just highlight the function and loop assign clauses. Again, we
can use the notation \CodeInline{n .. m} to indicate which parts of the
array are modified.



\levelFourTitle{Search and replace}


The last example we will detail to illustrate the proof of functions
with loops is the algorithm ``search and replace''. This algorithms will
selectively modify values in a range of memory locations. It is
generally harder to guide the tool in such a case, because on one hand
we must keep track of what is modified and what is not, and on the other
hand, the induction relies on this fact.

As an example, the first specification we can write for this function
could be this one:



\CodeBlockInput{c}{search_and_replace-0.c}



We use the logic function \CodeInline{\textbackslash{}at(v, Label)} that gives us the
value of the variable \CodeInline{v} at the program point \CodeInline{Label}.
If we look at the usage of this function here, we see that in the
invariant we try to establish a relation between the old values of the
array and the potentially new values:



\begin{CodeBlock}{c}
/*@
  loop invariant \forall size_t j; 0 <= j < i && \at(array[j], Pre) == old 
                   ==> array[j] == new;
  loop invariant \forall size_t j; 0 <= j < i && \at(array[j], Pre) != old 
                   ==> array[j] == \at(array[j], Pre);
*/
\end{CodeBlock}



For memory location, if it contained the value that must be replaced,
then it now contains the new value, else the value remains unchanged. In
fact, if we try to prove this invariant with WP, it fails. In such a
case, the simpler method is to add different assertions that will
express the different intermediate properties using assertions, that we
expect to be easily proved and that implies the invariant. Here, we can
easily notice that WP do not succeed in maintaining the knowledge that
we have not modified the end of the array yet:



\begin{CodeBlock}{c}
for(size_t i = 0; i < length; ++i){
    //@assert array[i] == \at(array[i], Pre); // échec de preuve
    if(array[i] == old) array[i] = new;
}
\end{CodeBlock}



We can add this information as an invariant:



\CodeBlockInput[13][26]{c}{search_and_replace-1.c}



And this time the proof will succeed. Note that if we try to prove this
invariant directly with the verification of the absence of RTE, Alt-Ergo
may not succeed (CVC4 succeeds without problem). In this case, we can
launch these proofs separately (first without, and then with the absence
of RTE checking) or else add assertions that allows to guide the proof
inside the loop:



\CodeBlockInput[24][33]{c}{search_and_replace-2.c}



As we will try to prove more complex properties, particularly when
programs involve loops, there will be a part of ``trial and error'' in
order to understand what the provers miss to establish the proof.

It can miss hypotheses. In this case, we can try to add assertions to
guide the prover. With some experience, we can read the content of the
proof obligations or try to perform the proof with the Coq interactive
prover to see whether the proof seems to be possible. Sometimes, the
prover just need more time, in such a case, we can (sometimes a lot)
augment the timeout value. Of course, the property can be too hard for
the prover, and in this case, we will have to write the proof ourselves
with an interactive prover.

Finally, the implementation can be indeed incorrect, and in this case we
have to fix it. Here, we will use test and not proof, because a test
allows us to prove the presence of a bug and to analyze this bug.
