A predicate is a property about different objects that can be true or false.
To sum up, we are writing predicates from the beginning of this tutorial in
precondition, postcondition, assertion and loop invariant. ACSL allows us to
name these predicates, as we could do for a boolean function in C, for example.
An important difference, however, is that predicates (as well as functions
that we will see later) must be pure. For example, they cannot produce side effects by
modifying a pointed value.

These predicates can receive some parameters. Moreover, they can also receive
some C labels that will allow us to establish relations between different
program points.

# Syntax

Predicates are introduced using ACSL annotations. The syntax is the following:

```c
/*@
  predicate named_predicate { Label0, Label1, ..., LabelN }(type0 arg0, type1 arg1, ..., typeN argN) =
    //a logic relations between all these things
*/
```

For example, we can define the predicate that checks whether an integer in
memory is changed between two particular program points:

```c
/*@
  predicate unchanged{L0, L1}(int* i) =
    \at(*i, L0) == \at(*i, L1);
*/
```

[[attention]]
| Keep in mind that passing a value to a predicate is done, as it is done in C,
| by value. We cannot write this predicate by directly passing `i` in parameter:
|
| ```c
| /*@
|   predicate unchanged{L0, L1}(int i) =
|     \at(i, L0) == \at(i, L1);
|  */
| ```
| Since `i` is just a copy of the received variable.

We can verify this code using our predicate:

```c
int main(){
  int i = 13;
  int j = 37;

 Begin:
  i = 23;
 
  //@assert ! unchanged{Begin, Here}(&i);
  //@assert   unchanged{Begin, Here}(&j);
}
```

We can also have a look at the goals generated by WP and notice that, even
it is slightly (syntactically) modified, the predicate is not unrolled by WP.
The provers will determine if they need to use the definition of the predicate.

As we said earlier, one important use of predicates (and logic functions) is to
make our specifications more readable and to factor it. An example can be to
write a predicate that expresses the validity of an array in read or write. It
allows us to avoid writing the complete expression every time we need it and to
make it readable quickly:

```c
/*@
  predicate valid_range_rw(int* t, integer n) =
    n >= 0 && \valid(t + (0 .. n-1));

  predicate valid_range_ro(int* t, integer n) =
    n >= 0 && \valid_read(t + (0 .. n-1));
*/

/*@
  requires 0 < length;
  requires valid_range_ro(array, length);
  //...
*/
int* search(int* array, size_t length, int element);
```

In this specification, we do not give an explicit label to predicates for
their definition, nor for their use. For the definition, Frama-C automatically
creates an implicit label. At predicate use, the given label is implicitly
`Here`. The fact we do not explicitly define the label in the definition of a
predicate does not forbid to explicitly give a label when we use it.

Of course, predicates can be defined in header files in order to produce a
utility library for specification for example.

# Abstraction

An other important use of predicates is to define the logical state of our
data structures when programs start to be more complex. Our data structures
must usually respect an invariant (again) that each manipulation function must
maintain in order to ensure that the data structure will always remain coherent
and usable through future calls.

It allows us to ease the reading of specifications. For example, we can define
the specification required to ensure the safety of a fixed size stack. It could
be done as illustrated here:

```c
struct stack_int{
  size_t top;
  int    data[MAX_SIZE];
};

/*@
  predicate valid_stack_int(struct stack_int* s) = // to be defined ;
  predicate empty_stack_int(struct stack_int* s) = // to be defined ;
  predicate full_stack_int(struct stack_int* s) =  // to be defined ;
*/

/*@
  requires \valid(s);
  assigns *s;
  ensures valid_stack_int(s) && empty_stack_int(s);
*/
void initialize(struct stack_int* s);

/*@
  requires valid_stack_int(s) && !full_stack_int(s);
  assigns  *s;
  ensures valid_stack_int(s);
*/
void push(struct stack_int* s, int value);

/*@
  requires valid_stack_int(s) && !empty_stack_int(s);
  assigns \nothing;
*/
int  top(struct stack_int* s);

/*@
  requires valid_stack_int(s) && !empty_stack_int(s);
  assigns *s;
  ensures valid_stack_int(s);
*/
void pop(struct stack_int* s);

/*@
  requires valid_stack_int(s);
  assigns \nothing;
  ensures \result == 1 <==> empty_stack_int(s);
*/
int is_empty(stack_int_t s);


/*@
  requires valid_stack_int(s);
  assigns \nothing;
  ensures \result == 1 <==> full_stack_int(s);
*/
int  is_full(stack_int_t s);
```

Here, the specification does not express functional properties. For example,
we do not specify that when we perform the push of a value, and then we ask for
the top of the stack, we get the same value. But we already have enough details
to ensure that, even if we cannot prove that we always get the right result
(behaviors such as "if I push $v$, top returns $v$"), we can still guarantee
that we do not produce runtime errors (if we provide correct predicates for the
stack, and prove that the implementation of our functions ensures that no
runtime errors can occur).
