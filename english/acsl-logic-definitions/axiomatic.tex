Axioms are properties we state to be true no matter the situation. It is
a good way to state complex properties that will allow the proof process
to be more efficient by abstracting their complexity. Of course, as any
property expressed as an axiom is assumed to be true, we have to be very
careful when we use them to defined properties: if we introduce a false
property in our assumptions, ``false'' becomes ``true'' and we can then
prove anything.



\levelThreeTitle{Syntax}


Axiomatic definitions are introduced using this syntax:



\begin{CodeBlock}{c}
/*@
  axiomatic Name_of_the_axiomatic_definition {
    // here we can define or declare functions and predicates

    axiom axiom_name { Label0, ..., LabelN }:
      // property ;

    axiom other_axiom_name { Label0, ..., LabelM }:
      // property ;

    // ... we can put as many axioms we need
  }
*/
\end{CodeBlock}



For example, we can write this axiomatic block:



\begin{CodeBlock}{c}
/*@
  axiomatic lt_plus_lt{
    axiom always_true_lt_plus_lt:
      \forall integer i, j; i < j ==> i+1 < j+1 ;
  }
*/
\end{CodeBlock}



And we can see that in Frama-C, this property is actually assumed to be
true:



\image{first-axiom.png}[First axiom, assumed to be true by Frama-C]


\begin{Spoiler}
  Currently, our automatic solvers are not
  powerful enough to compute \emph{the Answer to the Ultimate
    Question of Life, the Universe, and Everything}. We can help
  them by stating it as an axiom! Now, we just have to 
  understand the question to determine in which case this result can be
  useful \ldots{}

\begin{CodeBlock}{c}
/*@
  axiomatic Ax_answer_to_the_ultimate_question_of_life_the_universe_and_everything {
    logic integer the_ultimate_question_of_life_the_universe_and_everything{L} ;

    axiom answer{L}:
      the_ultimate_question_of_life_the_universe_and_everything{L} = 42;
  }
*/
\end{CodeBlock}
\end{Spoiler}


\levelFourTitle{Link with lemmas}



Lemmas and axioms allows to express the same types of properties.
Namely, properties expressed about quantified variables (and possibly
global variables, but it is quite rare since it is often difficult to
find a global property about such variables being both true and
interesting). Apart this first common point, we can also notice that
when we are not considering the definition of the lemma itself, lemmas
are assumed to be true by WP exactly as axioms are.




The only difference between lemmas and axioms from a proof point of view
is that we must provide a proof that each lemma is true, whereas an
axiom is always assumed to be true.



\levelThreeTitle{Recursive function or predicate definitions}


Axiomatic definition of recursive functions and predicates are
particularly useful since they will prevent provers to unroll the
recursion when is is possible.



The idea is then not to define directly the function or the predicate
but to declare it and then to define axioms that will specify its
behavior. If we come back to the factorial function, we can define it
axiomatically as follows:



\begin{CodeBlock}{c}
/*@
  axiomatic Factorial{
    logic integer factorial(integer n);
    
    axiom factorial_0:
      \forall integer i; i <= 0 ==> 1 == factorial(i) ;

    axiom factorial_n:
      \forall integer i; i > 0 ==> i * factorial(i-1) == factorial(i) ;
  }
*/
\end{CodeBlock}



In this axiomatic definition, our function do not have a body. Its
behavior is only defined by the axioms we have stated about it.



A small subtlety is that we must take care about the fact that if some
axioms state properties about the content of some pointed memory cells,
we have to specify considered memory blocks using the \texttt{reads}
notation in the declaration. If we omit such a specification, the
predicate or function will be considered to be stated about the received
pointers and not about pointer memory blocks. So, if the code modifies
the content of an array for which we had proven that the predicate or
function give some result, this result will not be considered to be
potentially different.




If, for example, we want to define that an array only contains 0s, we
have to write it as follows:



\CodeBlockInput[1][12]{c}{reset-0.c}



And we can again prove that our reset to 0 is correct with this new
definition:



\CodeBlockInput[16][30]{c}{reset-0.c}




Depending on the Frama-C or automatic solvers versions, the proof of the
preservation of the invariant could fail. A reason to this fail is the
fact that the prover forget that cells preceding the one we are
currently processing are actually still set to 0. We can add a lemma in
our knowledge base, stating that if a set of values of an array did not
change between two program points, the first one being a point where the
property ``zeroed'' is verified, then the property is still verified at
the second program point.



\CodeBlockInput[16][23]{c}{reset-1.c}



Then we can add an assertion to specify what did not change between the
beginning of the loop block (pointed by the label \texttt{L} in the
code) and the end (which is \texttt{Here} since we state the property at
the end):



\CodeBlockInput[38][42]{c}{reset-1.c}



Note that in this new version of the code, the property stated by our
lemma is not proved using automatic solver, that cannot reason by
induction. If the reader is curious, the (quite simple) Coq proof can be
found there:



\begin{Spoiler}
  \CodeBlockInput{coq}{reset-0-coq.v}
\end{Spoiler}


In this case study, using an axiomatic definition is not efficient: our
property can be perfectly expressed using the basic constructs of the
first order logic as we did before. Axiomatic definitions are meant to
be used to write definitions that are not easy to express using the
basic formalism provided by ACSL. It is here used to illustrate their
use with a simple example.



\levelThreeTitle{Consistency}


By adding axioms to our knowledge base, we can produce more complex
proofs since some part of these proofs, expressed by axioms, do not need
to be proved anymore (they are already specified to be true) shortening
the proof process. However, using axiomatic definitions, \textbf{we must
be extremely careful}. Indeed, even a small error could introduce false
in the knowledge base, making our whole reasoning futile. Our reasoning
would still be correct, but relying on false knowledge, it would only
learn incorrect things.



The simplest example is the following:



\CodeBlockInput{c}{false.c}



And everything is proved, comprising the fact that the dereferencing of
0 is valid:



\image{false-axiom.png}[Different false things proved to be true]


Of course, this example is extreme, we would not write such an axiom.
The problem is in fact that it is really easy to write an axiomatic
definition that is subtly false when we express more complex properties,
or adding assumptions about the global state of the system.




When we start to create axiomatic definitions, it is worth adding
assertions or postconditions requiring a proof of false that we expect
to fail to ensure that the definition is not inconsistent. However, it
is often not enough! If the subtlety that creates the inconsistency is
hard enough to find, provers could need a lot of information other than
the axiomatic definition itself to be able to find and use the
inconsistency, we then need to always be careful!




More specifically, specifying the values read by a function or a
predicate is important for the consistency of an axiomatic definition.
Indeed, as previously explained, if we do not specify what is read when
a pointer is received, an update of a value inside the array do not
invalidate a property known about the content of the array. In such a
case, the proof is performed but since the axiom do not talk about the
content of the array, we do not prove anything.




For example, in the function that resets an array to 0, if we modify the
axiomatic definition, removing the specification of the values that are
read by the predicate (\CodeInline{reads a[b .. e-1]}), the proof
will still be performed, but will not prove anything about the content
of the arrays.



\levelThreeTitle{xample: counting occurrences of a value}


In this example, we want to prove that an algorithm actually counts the
occurrences of a value inside an array. We start by axiomatically define
what is the number of occurrences of a value inside an array:



\CodeBlockInput[3][22]{c}{occurrences_of.c}



We have three different cases:

\begin{itemize}
\item
  the considered range of values is empty: the number of occurrences is
  0,
\item
  the considered range of values is not empty and the last element is
  the one we are searching: the number of occurrences is the number of
  occurrences in the current range without the last element, plus 1,
\item
  the considered range of values is not empty and the last element is
  not the one we are searching: the number of occurrences is the number
  of occurrences in the current range without the last element.
\end{itemize}

Then, we can write the C function that computes the number of
occurrences of a value inside an array and prove it:



\CodeBlockInput[24][42]{c}{occurrences_of.c}



An alternative way to specify, in this code, that \texttt{result} is at
most \texttt{i}, is to express a more general lemma about the number of
occurrences of a value inside an array, since we know that it is
comprised between 0 and the size of maximum considered range of values:



\begin{CodeBlock}{c}
/*@
lemma l_occurrences_of_range{L}:
  \forall int v, int* array, integer from, to:
    from <= to ==> 0 <= l_occurrences_of(v, a, from, to) <= to-from;
*/
\end{CodeBlock}



An automatic solver cannot discharge this lemma. It would be necessary
to prove it interactively using Coq, for example. By expressing, generic
manually proved lemmas, we can often add useful tools to provers to
manipulate more efficiently our axiomatic definitions, without directly
adding new axioms that would augment the chances to introduce errors.
Here, we still have to realize the proof of the lemma to have a complete
proof.



\levelThreeTitle{Example: sort}


We will prove a simple selection sort:



\CodeBlockInput[3]{c}{sort-0.c}



The reader can exercise by specifying and proving the search of the
minimum and the swap function. We hide there a correct version of these
specification and code, we will focus on the specification and the proof
of the sort function that is a interesting use case for axiomatic
definitions.



\begin{Spoiler}
  \CodeBlockInput[3][34]{c}{sort-1.c}
\end{Spoiler}


Indeed, a common error we could do, trying to prove a sort function,
would be to write this (true!) specification:



\CodeBlockInput[6]{c}{sort-incomplete.c}




\textbf{This specification is true}. But if we recall correctly the part
of the tutorial about specifications, we have to \emph{precisely}
express what we expect of the program. With this specification, we do
not prove all required properties expected for a sort function. For
example, this function correctly fullfils the specification:



\CodeBlockInput[8]{c}{sort-false.c}



Our specification does not express the fact that all elements initially
found inside the array must still be found inside the array after
executing the sort function. That is to say: the sort function produces
a sorted permutation of the original array.

Defining the notion of permutation is easily done using an axiomatic
definition. Indeed, to determine that an array is the permutation of an
other one, we can limit us to a few cases. First, the array is a
permutation of itself, then swapping to values of the array produces a
new permutation if we do not change anything else. And finally if we
create the permutation $p_2$ of $p_1$, and then the permutation
$p_3$ of $p_2$, then by transitivity $p_3$ is a permutation of
$p_1$.



The corresponding axiomatic definition is the following:



\CodeBlockInput[36][57]{c}{sort-1.c}



We can then specify that our sort function produces the sorted
permutation of the original array and we can then prove it by providing
the invariant of the function:



\CodeBlockInput[64][84]{c}{sort-1.c}



This time, our property is precisely defined, the proof is relatively
easy to produce, only requiring to add an assertion in the block of the
loop to state that it only performs a swap of values inside the array
(and then giving the transition to the next permutation). To define this
swap notion, we use a particular annotation (at line 16), introduced
using the keyword \texttt{ghost}. Here, the goal is to introduce a label
in the code that in fact does not exists from the program point of view,
and is only visible from a specification point of view. This is the
topic of the next section.
