Axioms are properties we state to be true no matter the situation. It is
a good way to state complex properties that will allow the proof process
to be more efficient by abstracting their complexity. Of course, as any
property expressed as an axiom is assumed to be true, we have to be very
careful when we use them to defined properties: if we introduce a false
property in our assumptions, ``false'' becomes ``true'' and we can then
prove anything.



\levelThreeTitle{Syntax}


Axiomatic definitions are introduced using this syntax:



\begin{CodeBlock}{c}
/*@
  axiomatic Name_of_the_axiomatic_definition {
    // here we can define or declare functions and predicates

    axiom axiom_name { Label0, ..., LabelN }:
      // property ;

    axiom other_axiom_name { Label0, ..., LabelM }:
      // property ;

    // ... we can put as many axioms we need
  }
*/
\end{CodeBlock}



For example, we can write this axiomatic block:



\begin{CodeBlock}{c}
/*@
  axiomatic lt_plus_lt{
    axiom always_true_lt_plus_lt:
      \forall integer i, j; i < j ==> i+1 < j+1 ;
  }
*/
\end{CodeBlock}



And we can see that in Frama-C, this property is actually assumed to be
true:



\image{first-axiom}[First axiom, assumed to be true by Frama-C]

\ref{l2:acsl-logic-definitions-answers}


\levelFourTitle{Link with lemmas}



Lemmas and axioms allows to express the same types of properties.
Namely, properties expressed about quantified variables (and possibly
global variables, but it is quite rare since it is often difficult to
find a global property about such variables being both true and
interesting). Apart this first common point, we can also notice that
when we are not considering the definition of the lemma itself, lemmas
are assumed to be true by WP exactly as axioms are.




The only difference between lemmas and axioms from a proof point of view
is that we must provide a proof that each lemma is true, whereas an
axiom is always assumed to be true.



\levelThreeTitle{Recursive function or predicate definitions}


Axiomatic definitions of recursive functions and predicates are
particularly useful since they will prevent provers to unroll the
recursion when is is possible.



The idea is then not to define directly the function or the predicate
but to declare it and then to define axioms that will specify its
behavior. If we come back to the factorial function, we can define it
axiomatically as follows:



\begin{CodeBlock}{c}
/*@
  axiomatic Factorial{
    logic integer factorial(integer n);
    
    axiom factorial_0:
      \forall integer i; i <= 0 ==> 1 == factorial(i) ;

    axiom factorial_n:
      \forall integer i; i > 0 ==> i * factorial(i-1) == factorial(i) ;
  }
*/
\end{CodeBlock}



In this axiomatic definition, our function has no body. Its
behavior is only defined by the axioms we have stated about it.



A small subtlety that we must take care of is the fact that if some
axioms state properties about the content of some pointed memory cells,
we have to specify considered memory blocks using the \texttt{reads}
notation in the declaration. If we omit such a specification, the
predicate or function will be considered to be stated about the received
pointers and not about pointer memory blocks. So, if the code modifies
the content of an array for which we had proven that the predicate or
function gives some result, this result will not be considered to be
potentially different.



For example, if we take the inductive property we stated for "zeroed" in the
previous chapter, we can write it using an axiomatic definition, and it will be
written like this:



\CodeBlockInput[1][12]{c}{reset-0.c}



While it is not necessary to specify are the memory location read in an
inductive definition, we have to specify such an information for axiomatically
defined properties.


\levelThreeTitle{Consistency}


By adding axioms to our knowledge base, we can produce more complex
proofs since some part of these proofs, expressed by axioms, do not need
to be proved anymore (they are already specified to be true) shortening
the proof process. However, using axiomatic definitions, \textbf{we must
be extremely careful}. Indeed, even a small error could introduce false
in the knowledge base, making our whole reasoning futile. Our reasoning
would still be correct, but relying on false knowledge, it would only
learn incorrect things.



The simplest example is the following:



\CodeBlockInput{c}{false.c}



And everything is proved, comprising the fact that the dereferencing of
0 is valid:



\image{false-axiom}[Different false things proved to be true]


Of course, this example is extreme, we would not write such an axiom.
The problem is in fact that it is really easy to write an axiomatic
definition that is subtly false when we express more complex properties,
or adding assumptions about the global state of the system.







When we start to create axiomatic definitions, it is worth adding
assertions or postconditions requiring a proof of false that we expect
to fail to ensure that the definition is not inconsistent. However, it
is often not enough! If the subtlety that creates the inconsistency is
hard enough to find, provers could need a lot of information other than
the axiomatic definition itself to be able to find and use the
inconsistency, we then need to always be careful!




More specifically, specifying the values read by a function or a
predicate is important for the consistency of an axiomatic definition.
Indeed, as previously explained, if we do not specify what is read when
a pointer is received, an update of a value inside the array does not
invalidate a property known about the content of the array. In such a
case, the proof is performed but since the axiom does not talk about the
content of the array, we do not prove anything.




For example, in the function that resets an array to 0, if we modify the
axiomatic definition, removing the specification of the values that are
read by the predicate (\CodeInline{reads a[b .. e-1]}), the proof
will still be performed, but will not prove anything about the content
of the arrays. For example, the following function:



\CodeBlockInput[16][25]{c}{all-zeroes-bad.c}



is proved to be correct, while we obviously changed a value in the array
and the value is not 0 anymore.



Note that unlike inductive definitions, where Coq provides us a way to control
that what we write in ACSL is relatively well defined, we do not have such a
mechanism for axiomatic definitions. Basically, even with Coq such a definition
is translated into a list of axioms that are thus assumed.



\levelThreeTitle{Example: counting occurrences of a value}


In this example, we want to prove that an algorithm actually counts the
occurrences of a value inside an array. We start by axiomatically defining
what is the number of occurrences of a value inside an array:



\CodeBlockInput[3][22]{c}{occurrences_of.c}



We have three different cases:

\begin{itemize}
\item
  the considered range of values is empty: the number of occurrences is
  0,
\item
  the considered range of values is not empty and the last element is
  the one we are searching: the number of occurrences is the number of
  occurrences in the current range without the last element, plus 1,
\item
  the considered range of values is not empty and the last element is
  not the one we are searching: the number of occurrences is the number
  of occurrences in the current range without the last element.
\end{itemize}

Then, we can write the C function that computes the number of
occurrences of a value inside an array and prove it:



\CodeBlockInput[24][42]{c}{occurrences_of.c}



An alternative way to specify, in this code, that \texttt{result} is at
most \texttt{i}, is to express a more general lemma about the number of
occurrences of a value inside an array, since we know that it is
comprised between 0 and the size of maximum considered range of values:



\begin{CodeBlock}{c}
/*@
lemma l_occurrences_of_range{L}:
  \forall int v, int* array, integer from, to:
    from <= to ==> 0 <= l_occurrences_of(v, a, from, to) <= to-from;
*/
\end{CodeBlock}



An automatic solver cannot discharge this lemma. It would be necessary
to prove it interactively using Coq, for example. By expressing generic
manually proved lemmas, we can often add useful tools to provers to
manipulate more efficiently our axiomatic definitions, without directly
adding new axioms that would augment the chances to introduce errors.
Here, we still have to realize the proof of the lemma to have a complete
proof.



\levelThreeTitle{Example: sort, again}



We will again illustrate the use of axiomatic definitions with a sort
function. This time, we will prove the insertion sort function:



\CodeBlockInput{c}{insert_sort.c}


The \CodeInline{insertion\_sort} function visits each value, from the beginning
of the array, to the end. For each of value $v$, it is inserted (using the
function \CodeInline{insert}) at the right place in the range of the already
sorted values (at the beginning of the array), by shifting them until we meet a
value that is smaller than $v$ or the first cell of the array.




We want to prove the same postcondition as we already proved for the selection
sort, that is: we want to create a sorted permutation of the original values.
Again, each iteration of the loop must ensure that the new configuration is a
permutation of the original values, and that the range from the beginning to
the current visited cell is sorted. All these properties are ensured by the
\CodeInline{insert} function. If we give a closer look to this function, we can
see that it records the value to insert (which is at the end of the range) in
the variable \CodeInline{value} and starting from this last position it shifts
all value until we meet a value that is smaller than the one we want to insert
or the first cell of the array.




First, let us provide a suitable contract and loop invariant to insertion sort
function. The contract is equivalent to the one provided to the selection sort.
Note however that the invariant is weaker: we do not needed the values that are
still not visited to be greater than the visited ones: we insert each value at
the right place.



\CodeBlockInput[64][81]{c}{insert_sort-contract.c}



Now, we can provide a contract to the insert function. The function requires
that the first part of the range is already sorted, and in exchange, it
guarantees to provide a range with one more value, that is still sorted and
is permutation of the original range:



\CodeBlockInput[43][61]{c}{insert_sort-contract.c}



Then, we need to provide a suitable invariant to the loop of the
\CodeInline{insert} function. And this time, we can see that we are in trouble.
Indeed, our inductive definition of the permutation specifies three cases: a
range is permutation of itself, or two (and only two) values have been swapped,
or the permutation is transitive. But none of this cases can be applied to our 
\CodeInline{insert} function, since the shifted range is not obtained by
successisively exchanging values, and that the wo other cases obviously do not
apply here.



Thus, we need to find a better definition to the notion of permutation. We can
notice that what we really need to provide is a way to say ``each value that
was previously in the array is still in the array and if several values were
equivalent, the number of occurrence of these values does not change''. And in
fact, this last part of the expression is enough to express our permutation.
A permutation of range is a range such that forall value, the number of
occurrences of this value in the array does not change from a program point to
another:



\CodeBlockInput[37][41]{c}{insert_sort-proved.c}



Starting from this definition, we can directly define lemmas that can help us
to deduce that some array that respect some properties from a label to another
is indeed a permutation. For example, that would be possible for the defintion
of the case \CodeInline{Swap} in our previous inductive definition. And it is
of course also possible for our shifted range.




Let us determine what are the required lemmas by first considering the function
\CodeInline{insert\_sort}. The only property that is not proved is the invariant
of the loop that expresses the fact that the array is a permutation of the
original array. How can we deduce it? (We will consider the proofs of the lemmas
later).




We can observe two facts: the first part of the array (from \CodeInline{beg} to
\CodeInline{i+1}) is a permutation of the values that were present in the array
at the beginning of the iteration (by the contract of the \CodeInline{insert}
function). The second part (from \CodeInline{i+1} to \CodeInline{end}) is
unchanged, so this is also a permutation of the values present at the beginning
of the iteration. While the first property is easily deduced, we can see that
the second one is not:



\begin{CodeBlock}{c}
  /*@
    loop invariant beg+1 <= i <= end ;
    loop invariant sorted(a, beg, i) ;
    loop invariant permutation{Pre, Here}(a,beg,end);
    loop assigns a[beg .. end-1], i ;
    loop variant end-i ;
  */
  for(size_t i = beg+1; i < end; ++i) {
    //@ ghost L:
    insert(a, beg, i);
    //@ assert permutation{L, Here}(a, beg, i+1); // PROVED
    //@ assert permutation{L, Here}(a, i+1, end); // NOT PROVED
  }
\end{CodeBlock}

So we need a first lemma for this property, we use a predicate
\CodeInline{shifted} to define \CodeInline{unchanged}, we will explain why
later.

\CodeBlockInput[53][60]{c}{insert-sort_proved.c}
\CodeBlockInput[67][70]{c}{insert-sort_proved.c}

And now, we can verify that those two sub-arrays are permutations:


\CodeBlockInput[127][140]{c}{insert-sort_proved.c}


Thus, since those two parts are permutations, the global array is a permutation
of the values present at the beginning of the iteration. However, this is not
directly proved, so we also need a lemma for this:



\CodeBlockInput[75][81]{c}{insert-sort_proved.c}


And now we can deduce that a loop iteration produces a permutation:



\begin{CodeBlock}{c}
    //@ ghost L:
    insert(a, beg, i);
    //@ assert permutation{L, Here}(a, beg, i+1);
    //@ assert unchanged{L, Here}(a, i+1, end);
    //@ assert permutation{L, Here}(a, i+1, end);
    //@ assert permutation{L, Here}(a, beg, end); // PROVED
\end{CodeBlock}



Finally, we need to add one more information, the permutation of a permutation
is also a permutation:



\CodeBlockInput[42][47]{c}{insert-sort_proved.c}



Now, we can have a closer look to the insertion function, by first considering
how to maintain that the function produces a permutation.




It shifts the different elements to the left until it reaches the beginning of
the array or an element that is smaller than the element to insert which is
initially at the end of the range, and is insert at the reached position. The
cells from the beginning of the array to the location of insertion are left
unchanged, so this is a permutation. We have a lemma for this, but we also have
to state that the values are unchanged as an invariant of the loop. The second
part of the array is a permutation because we rotate the elements, we need a
lemma to express this and to state at least that the element are shifted by the
loop as an invariant. Finally the union of the two permutations is a permutation,
and we also have a lemma for this.



So first, we can give a suitable invariant for the permutation:

\begin{itemize}
\item we provide the bounds of \CodeInline{i}
\item we state that the first part is left unchanged
\item we state that the last part is shifted to the left
\end{itemize}

as well as some assertions that we want to be verified.



\begin{CodeBlock}{c}
  /*@
    loop invariant beg <= i <= last ;
    loop invariant \forall integer k ; beg <= k <= i    ==> a[k] == \at(a[k], Pre) ;
    loop invariant \forall integer k ; i+1 <= k <= last ==> a[k] == \at(a[k-1], Pre) ;

    loop assigns i, a[beg .. last] ;
    loop variant i ;
  */
  while(i > beg && a[i - 1] > value){
    a[i] = a[i - 1] ;
    --i ;
  }

  a[i] = value ;

  //@ assert unchanged{Pre, Here}(a, beg, i) ;   // PROVED
  //@ assert permutation{Pre, Here}(a, beg, i) ; // PROVED

  //@ assert permutation{Pre, Here}(a, i, last+1) ; // NOT PROVED
\end{CodeBlock}


Then, for the last assertion, we need a lemma about the rotation of the
elements:


\CodeBlockInput[56][60]{c}{insert_sort-proved.c}
\CodeBlockInput[71][74]{c}{insert_sort-proved.c}



