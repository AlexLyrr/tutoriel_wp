Sometimes, a function can have behaviors that can be quite different
depending on the input. Typically, a function can receive a pointer to
an optional resource: if the pointer is \texttt{NULL}, we will have a
certain behavior, which will be different of the behavior expected when
the pointer is not \texttt{NULL}.

We have already seen a function that have different behaviors: the
\texttt{abs} function. We will use it again to illustrate behaviors. We
have two behaviors for the \texttt{abs} function: either the input is
positive or it is negative.

Behaviors allow us to specify the different cases for postconditions. We
introduce them using the \texttt{behavior} keyword. Each behavior will
have a name, the assumptions we have for the given case introduced with
the clause \texttt{assumes} and the associated postcondition. Finally,
we can ask WP to verify that behaviors are disjoint (to guarantee
determinism) and complete.

Behaviors are disjoint if for any (valid) input of the function, it
corresponds to the assumption (\texttt{assumes}) of a single behavior.
Behaviors are complete if any (valid) input of the function corresponds
to at least one behavior.

For example, for \texttt{abs} we can write the specification:



\CodeBlockInput{c}{abs.c}



It can be useful to experiment with the two possibilities to understand
the exact meaning of \CodeInline{complete} and \CodeInline{disjoint}:

\begin{itemize}
\item
  replace the assumption of \CodeInline{pos} with
  \CodeInline{val \textgreater{} 0}, in this case, behaviors will be
  disjoint but incomplete (we will miss \CodeInline{val == 0}),
\item
  replace the assumption of \CodeInline{neg} with
  \CodeInline{val \textless{}= 0}, in this case, behaviors will be
  complete but not disjoint (we will have two assumptions corresponding
  to \CodeInline{val == 0}.
\end{itemize}


\begin{Warning}
  Even if \CodeInline{assigns} is a postcondition, indicating different assigns
  in each behavior is currently not well-handled by WP. If we need to specify
  this, we will:
  \begin{itemize}
  \item put our \CodeInline{assigns} before the behaviors (as we have done in our
    example) with all potentially modified non-local elements,
  \item add in post-condition of each behaviors the elements that are in fact
    not modified by indicating their new value to be equal to the
    \CodeInline{\textbackslash{}old} one.
  \end{itemize}
\end{Warning}


Behaviors are useful to simplify the writing of specifications when
functions can have very different behaviors depending on their input.
Without them, specification would be defined using implications
expressing the same idea but harder to write and read (which would be
error-prone).



On the other hand, the translation of completeness and disjointness
would be necessarily written by hand which would be tedious and again
error-prone.
