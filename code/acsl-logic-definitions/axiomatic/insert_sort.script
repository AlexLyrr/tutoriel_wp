(* Generated by Frama-C WP *)

Goal typed_lemma_l_occurrences_of_union.
Hint l_occurrences_of_union,property.
Proof.
  Import Compound.

  Ltac norm := repeat(match goal with
  | [ _ : _ |- context [ ?i + 1 - 1 ]] => replace (i + 1 - 1) with i by omega
  | [ _ : _ |- context [ 0 + ?i ]] => replace (0 + i) with i by omega
  | [ _ : _ |- context [ ?i + 0 ]] => replace (i + 0) with i by omega
  end).
  intros e from cut to.
  generalize dependent cut.
  induction to using Z_induction with (m := from) ; intros cut mem page Hct Hfc He.
  * repeat(rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; auto ; try omega).
  * assert(EqNeq: { mem.[ (shift_sint32 page to) ] = e } + { mem.[ (shift_sint32 page to) ] <> e }) by
      repeat(decide equality).
    assert(Cut: cut < to + 1 \/ cut = to + 1) by omega ; inversion Cut as [ Inf | Eq ].
    + inversion_clear EqNeq as [ Eq | Neq ].
      - rewrite <- Eq.
        replace (mem .[ shift_sint32 page to]) with (mem .[ shift_sint32 page (to + 1 - 1)]) by (norm ; auto).
        rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_with_element with (i := to+1) ;
        [ rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_with_element with (i := to+1) | | ] ;
          norm ; try rewrite Eq ; auto ; try omega.
        assert(Simpl: forall x y z, x + y = z -> 1 + x + y = 1 + z) by (intros ; omega).
        apply Simpl.
        apply IHto ; auto ; omega.
      - rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_without_element with (i := to+1) ;
        [ rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_without_element with (i := to+1) | | | ] ;
          norm ; auto ; try omega.
        apply IHto ; auto ; omega.
    + rewrite Eq.
      rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; auto ; try omega.
Qed.

Goal typed_lemma_rotate_left_is_permutation.
Hint property,rotate_left_is_permutation.
Proof.
  Ltac norm := repeat(match goal with
  | [ _ : _ |- context [ ?i + 1 - 1 ]] => replace (i + 1 - 1) with i by omega
  | [ _ : _ |- context [ (1 + ?i) - 1 ]] => replace ((1 + i) - 1) with i by omega
  | [ H : context [ 1 + (?i - 1) ] |- _ ] => replace (1 + (i - 1)) with i in H by omega
  end).

  intros ba ea M1 M2 a Rot.
  unfold P_rotate_left in Rot.
  inversion_clear Rot as [ Same Rot' ].
  inversion_clear Rot' as [ Bound Shift ].

  assert(P_shifted M1 M2 1 a ba (ea-1)). {
    intros i ; intros.
    replace (M2 .[ shift_sint32 a i]) with (M2 .[ shift_sint32 a ((1 + i) - 1)]) by (norm ; auto).
    norm ; apply Shift ; omega.
  }
  clear Shift.
  intros i Hi.
  apply Q_shifted_maintains_occ with (i := i) in H ; auto.
  norm.
  rewrite <- Q_l_occurrences_of_union with (t := M2)(i_1 := ea-1) ; auto ; try omega.
  rewrite <- Q_l_occurrences_of_union with (t := M1)(i_1 := ba+1) ; auto ; try omega.

  assert (L_l_occurrences_of M2 i a (ea - 1) ea = L_l_occurrences_of M1 i a ba (ba + 1)). {
    assert(EqNeq: { M1 .[ shift_sint32 a ba] = i } + { M1 .[ shift_sint32 a ba] <> i }) 
        by repeat(decide equality).
    inversion_clear EqNeq as [ Eq | Neq ].
    + subst.
      rewrite <- Same.
      rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_with_element ; 
        norm ; try omega ; [| rewrite Same ; auto ].
      rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; 
        norm ; try omega ; [| rewrite Same ; auto ].
      rewrite Same.
      replace(M1 .[ shift_sint32 a ba]) with (M1 .[ shift_sint32 a (ba + 1 - 1)]) by (norm ; auto).
      rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_with_element ; norm ; try omega ; auto.
      rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; norm ; try omega ; auto.
    + rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_without_element ; 
        auto ; try omega.
      rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; auto ; try omega.
      replace ba with (ba + 1 - 1) by omega.
      replace (ba + 1 - 1 + 1) with (ba + 1) by omega.
      rewrite <- A_Occurrences_Axiomatic.Q_occurrences_positive_range_without_element ;
        norm ; try omega ; auto.
      rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; auto ; try omega.
  }
  rewrite <- H0.
  replace (ba + 1) with (1 + ba) by omega.
  omega.
Qed.

Goal typed_lemma_shifted_maintains_occ.
Hint property,shifted_maintains_occ.
Proof.
  Ltac norm := repeat(match goal with
  | [ _ : _ |- context [ ?i + 1 - 1 ]] => replace (i + 1 - 1) with i by omega
  | [ _ : _ |- context [ ?x + (?i + 1) - 1 ]] => replace (x + (i + 1) - 1) with (x + i) by omega
  end).
  intros ba ea s v M2 M1 a Hv H.
  induction ea using Z_induction with (m := ba).
  + rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; auto.
    rewrite A_Occurrences_Axiomatic.Q_occurrences_empty_range ; auto.
    omega.
  + assert (EqNeq: { M1.[ (shift_sint32 a ea) ] = v } + { M1.[ (shift_sint32 a ea) ] <> v }) by
      repeat(decide equality).
    assert (UP: P_shifted M2 M1 s a ba ea) by (intros i ; intros ; apply H ; omega).
    assert (Same: M2 .[ shift_sint32 a (s + ea)] = M1 .[ shift_sint32 a ea ]) by (apply H ; omega).
    apply IHea in UP.
    inversion EqNeq as [ Eq | Neq ].
    - replace (L_l_occurrences_of M1 v a ba (ea + 1))
         with (1 + L_l_occurrences_of M1 v a ba (ea + 1 - 1)).
      replace (L_l_occurrences_of M2 v a (s + ba) (s + (ea + 1)))
         with (1 + L_l_occurrences_of M2 v a (s + ba) (s + (ea + 1) - 1)).
      norm ; omega.
      * subst ; rewrite <- Same.
        replace (M2 .[ shift_sint32 a (s + ea)]) with (M2 .[ shift_sint32 a (s + (ea + 1) - 1)]) by (norm ; auto).
        apply A_Occurrences_Axiomatic.Q_occurrences_positive_range_with_element ; 
          norm ; subst ; try omega.
        rewrite Same ; auto.
      * subst.
        replace (M1 .[ shift_sint32 a ea]) with (M1 .[ shift_sint32 a (ea + 1 - 1)]) by (norm ; auto).
        apply A_Occurrences_Axiomatic.Q_occurrences_positive_range_with_element ; 
          norm ; subst ; auto ; omega.
    - replace (L_l_occurrences_of M1 v a ba (ea + 1))
         with (L_l_occurrences_of M1 v a ba (ea + 1 - 1)).
      replace (L_l_occurrences_of M2 v a (s + ba) (s + (ea + 1)))
         with (L_l_occurrences_of M2 v a (s + ba) (s + (ea + 1) - 1)).
      norm ; omega.
      * rewrite <- Same in Neq.
        apply A_Occurrences_Axiomatic.Q_occurrences_positive_range_without_element ; 
          norm ; auto ; omega.
      * apply A_Occurrences_Axiomatic.Q_occurrences_positive_range_without_element ; 
          norm ; auto ; omega.
Qed.

Goal typed_lemma_union_permutation.
Hint property,union_permutation.
Proof.
  intros from split to M1 M2 a L H P1 P2.
  unfold P_permutation in * .
  intros i Hi.
  rewrite <- Q_l_occurrences_of_union with (t := M1)(i_1 := split) ; try omega ; auto.
  rewrite <- Q_l_occurrences_of_union with (t := M2)(i_1 := split) ; try omega ; auto.
  rewrite P1 ; auto.
  rewrite P2 ; auto.
Qed.


