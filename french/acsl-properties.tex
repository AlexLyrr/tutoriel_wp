
Depuis le début de ce tutoriel, nous avons vu divers prédicats et fonctions 
logiques qui sont fournis par défaut en ACSL : \CodeInline{\textbackslash{}valid}, \CodeInline{\textbackslash{}valid\_read},
\CodeInline{\textbackslash{}separated}, \CodeInline{\textbackslash{}old} et \CodeInline{\textbackslash{}at}. Il en existe bien sûr d'autres mais 
nous n'allons pas les présenter un à un, le lecteur pourra se référer à 
\externalLink{la documentation (ACSL implementation)}{http://frama-c.com/download.html} 
pour cela (à noter : tout n'est pas nécessairement supporté par WP).



ACSL nous permet de faire plus que « simplement » spécifier notre code. Nous 
pouvons définir nos propres prédicats, fonctions, relations, etc. Le but est de
pouvoir abstraire nos spécifications. Cela nous permet de les factoriser (par 
exemple en définissant ce qu'est un tableau valide), ce qui a deux effets 
positifs pour nous : d'abord nos spécifications deviennent plus lisibles donc 
plus faciles à comprendre, mais cela permet également de réutiliser des preuves
déjà faites et donc de faciliter la preuve de nouveaux programmes.



\levelTwoTitle{Types primitifs supplémentaires}

\input{acsl-properties/some-logical-types}



\levelTwoTitle{Prédicats}

\input{acsl-properties/predicates}


\levelTwoTitle{Fonctions logiques}

\input{acsl-properties/functions}


\levelTwoTitle{Lemmes}

\input{acsl-properties/lemmas}



\horizontalLine



Dans cette partie, nous avons vu les constructions de ACSL qui nous permettent 
de factoriser un peu nos spécifications et d'exprimer des propriétés générales 
pouvant être utilisées par les prouveurs pour faciliter leur travail.



Toutes les techniques expliquées dans cette partie sont sûres, au sens où 
elles ne permettent \textit{a priori} pas de fausser la preuve avec des définitions 
fausses ou contradictoires. En tous cas, si la spécification n'utilise que ce
type de constructions et que chaque lemme, chaque pré-condition (aux points 
d'appels), chaque post-condition, chaque assertion, chaque variant et chaque 
invariant est correctement prouvé, le code est juste.



Parfois ces constructions ne sont pas suffisantes pour exprimer toutes nos 
propriétés ou pour prouver nos programmes. Les prochaines constructions que nous
allons voir vont nous ajouter de nouvelles possibilités à ce sujet, mais il 
faudra se montrer prudent dans leur usage car des erreurs pourraient nous 
permettre de créer des hypothèses fausses ou d'altérer le programme que nous 
vérifions.
